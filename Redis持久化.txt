Redis持久化
redis所有数据保持在内存中，对数据的更新将异步地保存到磁盘中

持久化方式：
1.快照		（redis RDB)
2.写日志 	 (redis AOF)


RDB
redis(内存) ——创建——>RDB文件(硬盘)
RDB文件(硬盘) ——启动载入——>redis(内存)

触发机制三种方式
save(同步)
save命令(阻塞，不消耗额外内存)
redis>save
文件策略：如存在老的RDB文件，替换 
复杂度：O(n)

bgsave(异步)
bgsave命令(后台命令，子进程,不阻塞，需要消耗额外内存)
redis>bgsave

自动(设置配置文件)
save 900 1
save 300 10
save 60 10000
dbfilename dump-${port}.rdb
dir /bigdiskpath
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes

触发机制-自动生成rdb文件
1.全量复制
2.debug reload
3.shutdown


AOF
写命令刷新到缓冲区，根据策略fsync到硬盘
三种策略     命令 			缺点 		 优点
always      每一次 			IO开销大     不丢失数据
everysec    每秒 		 	丢失1秒数据   只丢失1秒数据
no 			根据操作系统 		不可控 		 不用管

AOF重写(优化AOF文件命令)
减少磁盘占用量
加速恢复速度

实现的两种方式
bgrewiteaof命令
client->redis(master)--fork-->redis(子进程)--AOF重写->AOF文件
AOF重写配置
appendonly yes 							 使用aof基础
appendfilename "appendonly-${port}.aof"  文件名
appendfsync everysec					 策略
dir /bigdiskpath 						 目录
no-appendfsync-no-rewtire yes 			 aof重写的是否进行append操作
auto-aof-rewrite-percentage	 			 AOF文件增长率
auto-aof-rewrite-min-size   			 AOF文件重写需要的尺寸

统计
aof_current_size 		AOF当前尺寸(字节)
aof_base_size 			AOF上次启动和重写的尺寸(字节)


RDB与AOF
命令			RDB  	AOF
启动优先级 	低 		高
体积	 		小 		大
恢复速度 	快 		慢
数据安全性   丢数据  根据策略决定
操作轻重		重 		轻

最佳策略
小分片
缓存或者储存
监控(硬盘、内存、负载、网络)
足够内存


常见问题
1.fork操作
同步操作
与内存量息息相关：内存越大，耗时越长(与机器类型有关)
info:latest_fork_usec 查看上次执行fork的时间

改善fork
优先使用物理机或者搞笑支持fork操作的虚拟化技术
控制redis实例最大可用内存:maxmemory
合理配置Linux内存分配策略:vm.overcommit_memory=1
降低fork频率：例如放宽AOF重写自动触发时机，不必要的全量复制


2.进程外开销
CPU 开销：RDB和AOF文件生成，属于CPU密集型
 	优化：不做CPU绑定，不和CPU密集型部署
内存 开销：fork内存开销,copy-on-write
	 优化：echo never>/sys/kernel/mm/transparent_hugepage/enabled
硬盘 开销：AOF和RDB文件写入，可以结合iostat,iotop分析
 	 优化：不要和高硬盘负载服务部署在一起、no-appendfsync-on-rewrite = yes、根据写入量决定磁盘类型、单机多实例持久化文件目录可以考虑分盘


3.AOF追加阻塞
AOF阻塞定位：
redis日志：Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis

info persistence
127.0.0.1:6379>info persistence 			发生阻塞数量
aof_delayed_fsync:100



4.单机多实例部署
