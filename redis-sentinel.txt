主从复制问题
1.手动故障转移
2.写能力和存储能力受限

redis sentinel故障转移
1.多个sentinel发现并确认master有问题
2.选举出一个sentinel作为领导
3.选出一个slave作为master
4.通知其余slave成为新的master的slave
5.通知客户端主从变化
6.等待老的master复活成为新的master的slave

安装与配置
主节点配置：
port 7000
daemonize yes
pidfile /var/run/redis-7000.pid
logfile "7000.log"
dir "/opt/soft/redis/redis/data/"

从节点1
port 7001
daemonize yes
pidfile /var/run/redis-7001.pid
logfile "7001.log"
dir "/opt/soft/redis/redis/data/" 
slaveof 127.0.0.1 7000

从节点2
port 7002
daemonize yes
pidfile /var/run/redis-7002.pid
logfile "7002.log"
dir "/opt/soft/redis/redis/data/" 
slaveof 127.0.0.1 7000

sentinel配置
sentinel1:
port 26379
daemonize yes
dir /opt/soft/redis/data/
logfile "26379.log"
sentinel monitor mymaster 127.0.0.1 7000 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000

sentinel2:
port 26380
daemonize yes
dir /opt/soft/redis/data/
logfile "26380.log"
sentinel monitor mymaster 127.0.0.1 7000 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000

sentinel3:
port 26381
daemonize yes
dir /opt/soft/redis/data/
logfile "26381.log"
sentinel monitor mymaster 127.0.0.1 7000 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000




客户端实现基本原理
1.Client(Sentinel集合 + masterName)————遍历Sentinel节点集合，获取一个可用的Sentinel节点————>sentinel-1,sentinel-2,sentinel-3,....sentinel-N
2.Client(Sentinel集合 + masterName)————sentinel get-master-addr-by-name masterName ————> sentinel-k ————返回master节点 ————>Client(Sentinel集合 + masterName)
3.Client(Sentinel集合 + masterName)————role或者role replication————>master————节点角色信息————>client
4.sentinel-1,sentinel-2,sentinel-3,....sentinel-N————redis数据节点的变化通知————>Client(Sentinel集合 + masterName)


客户端接入流程
1.Sentinel地址集合
2.masterName
3.不是代理模式


jedis实现
String masterName = "mymaster";
Set<String> sentinelSet = new HashSet();
set.add("127.0.0.1:26379");
set.add("127.0.0.1:26380");
set.add("127.0.0.1:26381");

JedisSentinelPool sentinelPool = new JedisSentinePool(masterName, sentinelSet);
Jedis jedis = null;
try{
	jedis = sentinelPool.getResource();
}catch(Exception e){
	e.printStack();	
}finally{
	if(jedis != null){
		jedis.close();
	}
}


三个定时任务
1.每10秒info
2.每2秒发布订阅（每2秒每个sentinel通过master节点的channel交换信息(pub/sub)）
3.每1秒ping(每1秒每个sentinel对其他sentinel和redis执行ping)


主观下线：每个sentinel节点对redis节点失败的“偏见”
客观下线：所有sentinel节点对redis节点失败“达成共识”（超过quorum个统一）


领导者选举
通过sentinel is-master-down-by-addr命令都希望成为领导者
1.每个做主观下线的Sentinel节点向其他Sentinel节点发送命令，要求将它设置为领导者
2.收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将同意该请求，否则拒绝
3.如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum,那么它将成为领导者
4.如果此过程有过个Sentinel节点成为领导者，那么将等待一段时间重新进行选举。


故障转移（sentinel领导者节点完成）
1.从slave节点中选出一个“合适的”节点作为新的master节点
2.对上面的slave节点执行slaveof no one命令让它成为master节点
3.向剩余的slave节点发送命令，让它们成为新的master节点的slave节点，复制规则和parallel-syncs参数有关
4.更新对原来的master节点配置成slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。


选择“合适的”slave节点
1.选择slave-priprity(slave节点优先级)最高的slave节点，如果存在则返回，不存在则继续
2.选择复制偏移量最大的slave节点(复制最完整)，如果存在则返回，不存在则继续
3.选择runId最小的slave节点


常见运维问题


